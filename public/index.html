<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title id="pageTitle"></title>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <!-- Custom CSS -->
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- View Toggle Buttons -->
  <div class="view-toggle" id="viewToggle">
    <button class="active" data-view="config" id="configViewBtn"></button>
    <button data-view="map" id="mapViewBtn"></button>
  </div>


  <!-- Configuration View -->
  <div class="config-view active" id="configView">
    <div class="container">
      <h1 id="mainTitle"></h1>
      <div class="description">
        <img src="icon.png" alt="Plugin Icon" onerror="this.style.display='none'">
        <div class="description-text" id="pluginDescription"></div>
      </div>

      <div class="control-panel">
        <div class="switches">
          <div class="switch-container">
            <label class="switch">
              <input type="checkbox" id="enabledSwitch" name="enabled">
              <span class="slider"></span>
            </label>
            <span id="enabledLabel"></span>
          </div>
          
          <div class="switch-container">
            <label class="switch">
              <input type="checkbox" id="loggingSwitch" name="enableLogging">
              <span class="slider"></span>
            </label>
            <span id="loggingLabel"></span>
          </div>
          
          <div class="switch-container">
            <label class="switch">
              <input type="checkbox" id="debugSwitch" name="enableDebug">
              <span class="slider"></span>
            </label>
            <span id="debugLabel"></span>
          </div>
        </div>
        
        <button type="button" class="help-button" id="helpBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
            <line x1="12" y1="17" x2="12.01" y2="17"></line>
          </svg>
          <span id="helpBtnText"></span>
        </button>
      </div>

      <div id="status"></div>

      <div class="custom-dialog" id="confirmDialog">
        <div class="dialog-content">
          <div class="dialog-title" id="dialogTitle"></div>
          <div class="dialog-message" id="dialogMessage"></div>
          <div class="dialog-buttons">
            <button class="dialog-button secondary" id="dialogCancel"></button>
            <button class="dialog-button primary" id="dialogConfirm"></button>
          </div>
        </div>
      </div>

      <form id="configForm">
        <fieldset>
          <legend id="generalLegend"></legend>
          <div class="field-group">
            <span class="field-label" id="languageLabel"></span>
            <select name="language" id="languageSelect">
              <option value="de">Deutsch</option>
              <option value="en">English</option>
            </select>
            <span class="field-help" id="languageHelp"></span>
          </div>
          
          <div class="resource-info">
            <h4 id="resourceTitle"></h4>
            <p id="resourceObjects"></p>
            <p id="resourceWaterways"></p>
          </div>
        </fieldset>

        <fieldset id="areas">
          <legend id="areasLegend"></legend>
        </fieldset>

        <fieldset>
          <legend id="paramsLegend"></legend>
          
          <div class="field-group">
            <span class="field-label" id="pollLabel"></span>
            <input type="number" name="pollIntervalHours" min="1">
            <span class="field-help" id="pollHelp"></span>
          </div>
          
          <div class="field-group">
            <span class="field-label" id="daysLabel"></span>
            <input type="number" name="daysSpan" min="1" max="60">
            <span class="field-help" id="daysHelp"></span>
          </div>
          
          <div class="field-group">
            <span class="field-label" id="routesLabel"></span>
            <div class="input-with-button">
              <input type="text" name="openCpnGeoJsonPathRoutes" id="routesPath">
              <button type="button" class="file-button" id="routesFileBtn">üìÅ</button>
            </div>
            <span class="field-help" id="routesHelp"></span>
          </div>
          
          <div class="field-group">
            <span class="field-label" id="waypointsLabel"></span>
            <div class="input-with-button">
              <input type="text" name="openCpnGeoJsonPathWaypoints" id="waypointsPath">
              <button type="button" class="file-button" id="waypointsFileBtn">üìÅ</button>
            </div>
            <span class="field-help" id="waypointsHelp"></span>
          </div>
          
          <div class="field-group">
            <span class="field-label" id="moveLabel"></span>
            <input type="number" name="movePointMeters" min="0">
            <span class="field-help" id="moveHelp"></span>
          </div>
          
          <div class="field-group">
            <span class="field-label" id="sizeLabel"></span>
            <input type="number" name="pointSize" min="1">
            <span class="field-help" id="sizeHelp"></span>
          </div>
          
          <div class="field-group">
            <span class="field-label" id="colorLabel"></span>
            <input type="color" name="colorHex">
            <span class="field-help" id="colorHelp"></span>
          </div>
        </fieldset>

        <div class="button-group">
          <button type="submit" id="saveBtn"></button>
          <button type="button" id="restartBtn"></button>
          <button type="button" id="cancelBtn"></button>
          <button type="button" id="backBtn"></button>
        </div>
      </form>
    </div>
  </div>

  <!-- Map View -->
  <div class="map-view" id="mapView">
    <div id="map"></div>
	<div class="map-info" id="mapInfo">
	  <div>
		<input type="checkbox" id="toggleWaterways" checked>
		<strong id="mapWaterwaysLabel">Wasserwege:</strong>
		<span id="mapWaterwaysCount">0</span>
	  </div>
	  <div>
		<input type="checkbox" id="toggleClosures" checked>
		<strong id="mapClosuresLabel">Sperrungen:</strong>
		<span id="mapClosuresCount">0</span>
	  </div>
	  <div style="margin-top:0.5em;">
		<date-range-component maxDays="60"></date-range-component>
	  </div>
	</div>

  </div>

  <!-- External Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/de.js"></script>
  <script type="module" src="date-range-component.js"></script>
  <script src="translations.js"></script>
  <script src="api-bridge.js"></script>

  <script>
    // ============================================================
    // CONFIGURATION VIEW
    // ============================================================

    const configUrl = '/plugins/signalk-vaarweginformatie-blocked/config';
    const restartUrl = '/plugins/signalk-vaarweginformatie-blocked/restart';

    let initialConfig = null;
    let currentLang = 'de';
    let bridge = new VaarweginformatieApiBridge();
	let data = null;
	let mapFilter = {};;

    // UI Elements
    const mainTitle = document.getElementById('mainTitle');
    const generalLegend = document.getElementById('generalLegend');
    const languageLabel = document.getElementById('languageLabel');
    const languageHelp = document.getElementById('languageHelp');
    const areasLegend = document.getElementById('areasLegend');
    const paramsLegend = document.getElementById('paramsLegend');
    const pollLabel = document.getElementById('pollLabel');
    const pollHelp = document.getElementById('pollHelp');
    const daysLabel = document.getElementById('daysLabel');
    const daysHelp = document.getElementById('daysHelp');
    const routesLabel = document.getElementById('routesLabel');
    const routesHelp = document.getElementById('routesHelp');
    const waypointsLabel = document.getElementById('waypointsLabel');
    const waypointsHelp = document.getElementById('waypointsHelp');
    const moveLabel = document.getElementById('moveLabel');
    const moveHelp = document.getElementById('moveHelp');
    const sizeLabel = document.getElementById('sizeLabel');
    const sizeHelp = document.getElementById('sizeHelp');
    const colorLabel = document.getElementById('colorLabel');
    const colorHelp = document.getElementById('colorHelp');
    const saveBtn = document.getElementById('saveBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const backBtn = document.getElementById('backBtn');
    const restartBtn = document.getElementById('restartBtn');
    const languageSelect = document.getElementById('languageSelect');
    const enabledSwitch = document.getElementById('enabledSwitch');
    const helpBtn = document.getElementById('helpBtn');

	function detectContext() {
	  // 1. L√§uft die Seite im iframe?
	  const inIframe = window.self !== window.top;

	  // 2. Root Node pr√ºfen (Shadow DOM?)
	  const rootNode = document.documentElement.getRootNode();
	  const inShadowDom = rootNode instanceof ShadowRoot;

	  // 3. Fragment-Erkennung: fehlen typische Strukturen?
	  // (z. B. kein <head> oder <body>)
	  const isFragment = !document.head || !document.body;

	  let context;
	  if (inIframe) {
		context = "iframe";
	  } else if (inShadowDom) {
		context = "shadow-dom";
	  } else if (isFragment) {
		context = "fragment";
	  } else {
		context = "main-document";
	  }

	  return context;
	}

	// ============================================================
	// AUTOMATISCHER START-MODUS (detectContext + ?mode=map)
	// ============================================================

	async function startAutoMode() {
	  const params = new URLSearchParams(window.location.search);
	  const mode = params.get("mode");
	  const context = detectContext();

	  const mustShowMap =
		mode === "map" ||
		context !== "main-document";

	  if (!mustShowMap) return;

	  // Buttons ausblenden
	  document.getElementById("viewToggle").style.display = "none";

	  // Ansicht umschalten
	  document.getElementById("configView").classList.remove("active");
	  document.getElementById("mapView").classList.add("active");

	  // WICHTIG: Warten bis initialConfig gesetzt ist!
	  const waitForConfig = () =>
		new Promise(resolve => {
		  const timer = setInterval(() => {
			if (initialConfig !== null) {
			  clearInterval(timer);
			  resolve();
			}
		  }, 50);
		});

	  await waitForConfig();

	  // Jetzt ist initialConfig sicher gesetzt ‚Üí Map laden
	  initMap();
	  await loadMapData();

	  // Optional Poll-Interval starten
	  if (initialConfig.pollIntervalHours) {
		mapUpdateTimer = setInterval(
		  loadMapData,
		  initialConfig.pollIntervalHours * 3600000
		);
	  }
	}


    function showStatus(message, isError = false) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = isError ? 'error' : 'success';
      setTimeout(() => {
        status.style.display = 'none';
      }, 5000);
    }

    function setLoading(isLoading) {
      const form = document.getElementById('configForm');
      if (isLoading) {
        form.classList.add('loading');
      } else {
        form.classList.remove('loading');
      }
    }

    function updateUI(lang) {
      const t = translations[lang];
      document.title = t.title;
      mainTitle.textContent = t.title;
      document.querySelector('.description-text').innerHTML = t.description;
      generalLegend.textContent = t.generalLegend;
      languageLabel.textContent = t.languageLabel;
      languageHelp.textContent = t.languageHelp;
      areasLegend.textContent = t.areasLegend;
      paramsLegend.textContent = t.paramsLegend;
      pollLabel.textContent = t.pollInterval;
      pollHelp.innerHTML = t.pollHelp;
      daysLabel.textContent = t.daysSpan;
      daysHelp.textContent = t.daysHelp;
      routesLabel.textContent = t.routesPath;
      routesHelp.textContent = t.routesHelp;
      waypointsLabel.textContent = t.waypointsPath;
      waypointsHelp.textContent = t.waypointsHelp;
      moveLabel.textContent = t.moveMeters;
      moveHelp.textContent = t.moveHelp;
      sizeLabel.textContent = t.pointSize;
      sizeHelp.textContent = t.sizeHelp;
      colorLabel.textContent = t.color;
      colorHelp.textContent = t.colorHelp;
      saveBtn.textContent = t.save;
      restartBtn.textContent = t.restart;
      cancelBtn.textContent = t.cancel;
      backBtn.textContent = t.back;
      document.getElementById('enabledLabel').textContent = t.enabledLabel;
      document.getElementById('loggingLabel').textContent = t.loggingLabel;
      document.getElementById('debugLabel').textContent = t.debugLabel;
      document.getElementById('helpBtnText').textContent = t.helpBtnText;
      document.getElementById('configViewBtn').textContent = t.configViewBtn;
      document.getElementById('mapViewBtn').textContent = t.mapViewBtn;
      updateResourceInfo(lang);
    }

    function updateResourceInfo(lang) {
      const t = translations[lang];
      const resourceInfoDiv = document.querySelector('.resource-info');
      
      // Nur anzeigen wenn Plugin enabled ist UND die Sprache im initialConfig gespeichert ist
      if (!enabledSwitch.checked) {
        resourceInfoDiv.style.display = 'none';
        return;
      }
      
      // Pr√ºfe ob die aktuelle Sprache mit der gespeicherten Sprache √ºbereinstimmt
      const savedLanguageIsDe = initialConfig.language === true;
      const currentLanguageIsDe = lang === 'de';
      
      if (savedLanguageIsDe !== currentLanguageIsDe) {
        resourceInfoDiv.style.display = 'none';
        return;
      }
      
      resourceInfoDiv.style.display = 'block';
      const host = window.location.hostname;
      const port = window.location.port || '3000';
      const resourceType = lang === 'de' ? 'Sperrungen' : 'Closures';
      
      const objectsUrl = `http://${host}:${port}/signalk/v2/api/resources/${resourceType}`;
      const waterwaysUrl = `http://${host}:${port}/signalk/v2/api/resources/routes`;
      
      document.getElementById('resourceTitle').textContent = t.resourceTitle;
      document.getElementById('resourceObjects').innerHTML = 
        `${t.resourceObjects} <a href="${objectsUrl}" target="_blank"><code>${objectsUrl}</code></a>`;
      document.getElementById('resourceWaterways').innerHTML = 
        `${t.resourceWaterways} <a href="${waterwaysUrl}" target="_blank"><code>${waterwaysUrl}</code></a>`;
    }

    function normalizeConfig(raw) {
      const cfg = { ...(raw || {}) };
      
      // Sprache: true=de, false=en
      if (typeof cfg.language !== 'undefined') {
        cfg.language = Boolean(cfg.language);
      }
      
      if (typeof cfg.enabled !== 'undefined') cfg.enabled = Boolean(cfg.enabled);
      if (typeof cfg.enableLogging !== 'undefined') cfg.enableLogging = Boolean(cfg.enableLogging);
      if (typeof cfg.enableDebug !== 'undefined') cfg.enableDebug = Boolean(cfg.enableDebug);
      areaOrder.forEach(key => { if (typeof cfg[key] === 'undefined') cfg[key] = false; });
      ['pollIntervalHours','daysSpan','movePointMeters','pointSize'].forEach(n => {
        if (typeof cfg[n] !== 'undefined') cfg[n] = Number(cfg[n]);
      });
      return cfg;
    }

    function renderAreas(lang, config) {
      const container = document.getElementById('areas');
      Array.from(container.querySelectorAll('label')).forEach(l => l.remove());

      // Sortiere Gebiete alphabetisch nach Sprache (au√üer "All areas" bleibt erste)
      const sortedAreas = [
        'All areas',
        ...areaOrder.slice(1).sort((a, b) => 
          areaLabels[a][lang].localeCompare(areaLabels[b][lang], lang === 'de' ? 'de-DE' : 'en-US')
        )
      ];

      sortedAreas.forEach(key => {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.name = key;
        if (key === 'All areas') cb.id = 'allAreas';

        const span = document.createElement('span');
        span.className = 'areaLabel';
        span.textContent = areaLabels[key][lang];

        label.appendChild(cb);
        label.appendChild(document.createTextNode(' '));
        label.appendChild(span);
        container.appendChild(label);

        if (config && typeof config[key] !== 'undefined') cb.checked = Boolean(config[key]);
      });

      const allAreasCB = document.getElementById('allAreas');
      const others = Array.from(container.querySelectorAll('input[type="checkbox"]')).filter(cb => cb !== allAreasCB);

      function applyAllAreasLogic() {
        if (allAreasCB.checked) {
          others.forEach(cb => { cb.checked = false; cb.disabled = true; });
        } else {
          others.forEach(cb => { cb.disabled = false; });
        }
      }
      
      function checkIfAllAreasNeeded() {
        const anyChecked = others.some(cb => cb.checked);
        if (!anyChecked && !allAreasCB.checked) {
          allAreasCB.checked = true;
          applyAllAreasLogic();
        }
      }
      
      allAreasCB.addEventListener('change', applyAllAreasLogic);
      others.forEach(cb => cb.addEventListener('change', () => {
        if (cb.checked) { 
          allAreasCB.checked = false; 
          applyAllAreasLogic(); 
        } else {
          checkIfAllAreasNeeded();
        }
      }));
      applyAllAreasLogic();
      checkIfAllAreasNeeded();
    }

    function showConfirmDialog(message, title) {
      return new Promise((resolve) => {
        const dialog = document.getElementById('confirmDialog');
        const t = translations[currentLang];
        document.getElementById('dialogTitle').textContent = title || t.unsavedTitle;
        document.getElementById('dialogMessage').textContent = message;
        document.getElementById('dialogConfirm').textContent = t.yes;
        document.getElementById('dialogCancel').textContent = t.no;
        
        dialog.classList.add('show');
        
        const handleConfirm = () => {
          dialog.classList.remove('show');
          resolve(true);
        };
        
        const handleCancel = () => {
          dialog.classList.remove('show');
          resolve(false);
        };
        
        document.getElementById('dialogConfirm').addEventListener('click', handleConfirm);
        document.getElementById('dialogCancel').addEventListener('click', handleCancel);
      });
    }

    function collectConfig() {
      const configuration = {};

      // Switches
      configuration.enabled = document.getElementById('enabledSwitch').checked;
      configuration.enableLogging = document.getElementById('loggingSwitch').checked;
      configuration.enableDebug = document.getElementById('debugSwitch').checked;

      // Language
      const langValue = document.getElementById('languageSelect').value;
      configuration.language = (langValue === 'de');

      // Parameter - WICHTIG: Zahlen m√ºssen als Number sein, nicht String!
      configuration.pollIntervalHours = Number(document.querySelector('[name="pollIntervalHours"]').value) || 0;
      configuration.daysSpan = Number(document.querySelector('[name="daysSpan"]').value) || 0;
      configuration.openCpnGeoJsonPathRoutes = document.querySelector('[name="openCpnGeoJsonPathRoutes"]').value;
      configuration.openCpnGeoJsonPathWaypoints = document.querySelector('[name="openCpnGeoJsonPathWaypoints"]').value;
      configuration.movePointMeters = Number(document.querySelector('[name="movePointMeters"]').value) || 0;
      configuration.pointSize = Number(document.querySelector('[name="pointSize"]').value) || 0;
      configuration.colorHex = document.querySelector('[name="colorHex"]').value;

      // Gebiete
      areaOrder.forEach(area => {
        const checkbox = document.querySelector(`[name="${area}"]`);
        if (checkbox) {
          configuration[area] = checkbox.checked;
        }
      });

      return configuration;
    }

    // Config Form Events
    helpBtn.addEventListener('click', () => {
      window.open('https://github.com/formifan2002/signalk-vaarweginformatie-blocked/blob/main/README.md', '_blank');
    });

    function updateRestartButton() {
      if (enabledSwitch.checked) {
        restartBtn.disabled = false;
        restartBtn.style.opacity = '1';
      } else {
        restartBtn.disabled = true;
        restartBtn.style.opacity = '0.5';
      }
    }

    enabledSwitch.addEventListener('change', updateRestartButton);

    enabledSwitch.addEventListener('change', () => {
      updateResourceInfo(currentLang);
      updateMapButtonState();
    });

    enabledSwitch.addEventListener('change', () => {
      updateResourceInfo(currentLang);
    });

    document.getElementById('routesFileBtn').addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.gpx';
      input.onchange = e => {
        const file = e.target.files[0];
        if (file) {
          document.getElementById('routesPath').value = file.path || file.webkitRelativePath || `/path/to/${file.name}`;
        }
      };
      input.click();
    });

    document.getElementById('waypointsFileBtn').addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.gpx';
      input.onchange = e => {
        const file = e.target.files[0];
        if (file) {
          document.getElementById('waypointsPath').value = file.path || file.webkitRelativePath || `/path/to/${file.name}`;
        }
      };
      input.click();
    });

    languageSelect.addEventListener('change', e => {
      currentLang = e.target.value;
      updateUI(currentLang);
      updateResourceInfo(currentLang);
      updateMapLabels();
      const currentConfig = normalizeConfig(collectConfig());
      renderAreas(currentLang, currentConfig);
    });

    // Load Config
    fetch(configUrl)
      .then(res => res.json())
      .then(data => {
        const raw = data.configuration || {};
        // Speichere die rohen Werte als initialConfig f√ºr sp√§teren Vergleich
        initialConfig = { ...raw, enabled: data.enabled, enableLogging: data.enableLogging, enableDebug: data.enableDebug };
        
        // F√ºr die UI: normalisiere
        const normalized = normalizeConfig(initialConfig);
        
        currentLang = normalized.language ? 'de' : 'en';
        languageSelect.value = currentLang;
        updateUI(currentLang);
        renderAreas(currentLang, normalized);

        document.getElementById('enabledSwitch').checked = Boolean(normalized.enabled);
        document.getElementById('loggingSwitch').checked = Boolean(normalized.enableLogging);
        document.getElementById('debugSwitch').checked = Boolean(normalized.enableDebug);
        updateRestartButton();
        updateResourceInfo(currentLang);

        ['pollIntervalHours','daysSpan','openCpnGeoJsonPathRoutes','openCpnGeoJsonPathWaypoints','movePointMeters','pointSize','colorHex']
         .forEach(name => {
           const el = document.querySelector(`[name="${name}"]`);
           if (el && normalized[name] !== undefined) {
             el.value = normalized[name];
           }
         });
         
        // WICHTIG: Nach dem Laden muss initialConfig die exakten Werte von den Form-Elementen haben
        // Damit der Vergleich sp√§ter stimmt
        initialConfig = collectConfig();
      })
      .catch(err => {
        showStatus((translations[currentLang]?.loadError || 'Fehler beim Laden: ') + err.message, true);
      });

    // Save Config
    document.getElementById('configForm').addEventListener('submit', e => {
      e.preventDefault();
      const collected = collectConfig();
      const normalized = normalizeConfig(collected);
      const { enabled, enableLogging, enableDebug, ...configuration } = normalized;
      const payload = { configuration, enabled: Boolean(enabled), enableLogging: Boolean(enableLogging), enableDebug: Boolean(enableDebug) };

      setLoading(true);
      fetch(configUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      .then(res => res.json())
      .then(() => {
        showStatus(translations[currentLang].saveSuccess);
        // initialConfig mit den AKTUELLEN Form-Werten aktualisieren
        initialConfig = collectConfig();
        updateMapButtonState();
        
        if (!enabled) return Promise.resolve();
        return fetch(restartUrl, { method: 'POST' });
      })
      .then(res => {
        if (res && !res.ok) throw new Error(res.status);
        return res ? res.json() : null;
      })
      .then(() => {
        showStatus(translations[currentLang].restartSuccess);
        loadMapData();
      })
      .catch(err => {
        showStatus(translations[currentLang].saveError + err.message, true);
      })
      .finally(() => setLoading(false));
    });

    restartBtn.addEventListener('click', () => {
      setLoading(true);
      fetch(restartUrl, { method: 'POST' })
        .then(res => res.json())
        .then(() => showStatus(translations[currentLang].restartSuccess))
        .catch(err => showStatus(translations[currentLang].restartError + err.message, true))
        .finally(() => setLoading(false));
    });

    cancelBtn.addEventListener('click', () => window.history.back());

    backBtn.addEventListener('click', async () => {
      const current = collectConfig();
      const initial = initialConfig;
      
      // Einfacher direkter Vergleich der Rohwerte
      const changed = JSON.stringify(current) !== JSON.stringify(initial);
      
      if (changed) {
        const confirmed = await showConfirmDialog(translations[currentLang].unsavedWarning, translations[currentLang].unsavedTitle);
        if (confirmed) window.history.back();
      } else {
        window.history.back();
      }
    });

    // Map-Button Validierung
    function updateMapButtonState() {
      const current = normalizeConfig(collectConfig());
      const initial = normalizeConfig(initialConfig);
      const currentStr = JSON.stringify(current);
      const initialStr = JSON.stringify(initial);
      const hasChanges = currentStr !== initialStr;
      
      const mapBtn = document.getElementById('mapViewBtn');
      const warningDiv = document.getElementById('unsavedWarningDiv');
      
      if (hasChanges) {
        mapBtn.disabled = true;
        mapBtn.style.opacity = '0.5';
        mapBtn.style.cursor = 'not-allowed';
		if (!warningDiv) {
		  const div = document.createElement('div');
		  div.id = 'unsavedWarningDiv';
		  div.textContent = translations[currentLang].unsavedChanges;

		  // Styling kannst du √ºber CSS machen, nicht inline:
		  div.classList.add('unsaved-warning');

		  // Statt ins body ‚Üí in die view-toggle Box einf√ºgen
		  const viewToggle = document.getElementById('viewToggle');
		  viewToggle.appendChild(div);
		}
      } else {
        mapBtn.disabled = false;
        mapBtn.style.opacity = '1';
        mapBtn.style.cursor = 'pointer';
        if (warningDiv) warningDiv.remove();
      }
    }

    // √úberwache Eingabefelder f√ºr √Ñnderungen
    document.getElementById('configForm').addEventListener('input', (e) => {
      updateMapButtonState();
    });
    
    document.getElementById('configForm').addEventListener('change', (e) => {
      updateMapButtonState();
    });

    // ============================================================
    // MAP VIEW
    // ============================================================

    let mapInstance = null;
    let mapLayers = { waterways: L.featureGroup(), closures: L.featureGroup() };
    let mapUpdateTimer = null;

    function initMap() {
      if (mapInstance) return;
      
      mapInstance = L.map('map').setView([52.5, 5.0], 8);

      L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        maxZoom: 19,
        crossOrigin: true
      }).addTo(mapInstance);

      L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openseamap.org/">OpenSeaMap</a>',
        maxZoom: 18,
        opacity: 0.7,
        crossOrigin: true
      }).addTo(mapInstance);

      mapLayers.waterways.addTo(mapInstance);
      mapLayers.closures.addTo(mapInstance);
    }

	async function loadMapData() {
	  try {

		data = await bridge.getAllData(currentLang);
		renderMapLayers(data);

		// Anzahl der tats√§chlich dargestellten Layer
		const waterwaysCount = mapLayers.waterways.getLayers().length;
		const closuresCount = mapLayers.closures.getLayers().length;

		document.getElementById('mapWaterwaysCount').textContent = waterwaysCount;
		document.getElementById('mapClosuresCount').textContent = closuresCount;
	  } catch (err) {
		console.error('Map data error:', err);
	  }
	}

    function renderMapLayers(data) {
      mapLayers.waterways.clearLayers();
      mapLayers.closures.clearLayers();

	if (data.waterways && typeof data.waterways === 'object') {
	  Object.entries(data.waterways).forEach(([key, entry]) => {
		// Nur Keys, die mit "blocked-route-" anfangen
		if (key.startsWith('blocked-route-')) {
		  const feature = entry.feature;
		  if (feature?.geometry?.type === 'LineString' || feature?.geometry?.type === 'MultiLineString') {
			L.geoJSON(feature, {
			  style: { color: initialConfig.colorHex || '#ff6b6b', weight: 3, opacity: 0.8 },
			  onEachFeature: (f, l) => {
				const name = entry.name || f.properties?.name;
				const description = entry.description || f.properties?.description;

				let html = '<div class="popup-content">';
				if (name) html += `<strong>${name}</strong><br>`;
				if (description) {
				  // " | " durch Zeilenumbr√ºche ersetzen
				  html += description.replace(/\s*\|\s*/g, '<br>');
				}
				html += '</div>';

				if (name || description) {
				  l.bindPopup(html);
				}
			  }
			}).addTo(mapLayers.waterways);
		  }
		}
	  });
	}


	if (data.closures && typeof data.closures === 'object') {
	  Object.values(data.closures).forEach(set => {
		const features = set?.values?.features;
		if (Array.isArray(features)) {
		  const styleCfg = set.styles?.default || {};
		  const stroke = styleCfg.stroke || '#333';
		  const fill = styleCfg.fill || (initialConfig.colorHex || '#4ecdc4');
		  const width = Number(styleCfg.width) || (initialConfig.pointSize || 6);

		  features.forEach(feature => {
			const blockages = feature.properties?.blockages || [];
			const now = new Date();

			// Pr√ºfen, ob mindestens ein Blockage aktuell g√ºltig ist
			const isActiveInMapFilter = blockages.some(b => {
			  // Wenn mapFilter leer ist oder beide Werte null -> immer true
			  if (!mapFilter || Object.keys(mapFilter).length === 0 ||
				  (mapFilter.start === null && mapFilter.end === null)) {
				return true;
			  }

			  // Blockage-Start/Ende als Unix-Timestamps
			  const start = b.startDate ? new Date(b.startDate).getTime() : null;
			  const end   = b.endDate   ? new Date(b.endDate).getTime()   : null;

			  // Filtergrenzen setzen
			  const filterStart = mapFilter.start ?? -Infinity;
			  const filterEnd   = mapFilter.end   ?? Infinity;

			  // √úberschneidung pr√ºfen
			  return (start ?? -Infinity) <= filterEnd && (end ?? Infinity) >= filterStart;
			});

			if (isActiveInMapFilter) {
			  L.geoJSON(feature, {
				pointToLayer: (f, latlng) => L.circleMarker(latlng, {
				  radius: width,
				  fillColor: fill,
				  color: stroke,
				  weight: 2,
				  opacity: 0.8,
				  fillOpacity: 0.7
				}),
				onEachFeature: (f, l) => {
				  let html = '<div class="popup-content">';
				  if (f.properties?.name) html += `<strong>${f.properties.name}</strong><br>`;
	              if (blockages.length > 0) {
	                const labelClosure = currentLang === 'de' ? 'Sperrungen:' : 'Closures:';
					const labelFrom = currentLang === 'de' ? 'ab ' : 'from ';
	                html += `<br><em>${labelClosure}</em><ul>`;
	                blockages.forEach(b => {
					const opts = {
					  day: "2-digit",
					  month: "2-digit",
					  year: "2-digit",
					  hour: "2-digit",
					  minute: "2-digit"
					};
					const start = b.startDate 
					  ? new Date(b.startDate).toLocaleString(currentLang === 'de' ? 'de-DE' : 'en-US', opts) 
					  : '';

					const end = b.endDate 
					  ? new Date(b.endDate).toLocaleString(currentLang === 'de' ? 'de-DE' : 'en-US', opts) 
					  : '';
	              	html += `<li>${end ? '' : labelFrom}${start}${end ? ' ‚Äì ' + end : ''}</li>`;
	                });
	                html += '</ul>';
	              }
				  html += '</div>';
				  l.bindPopup(html);
				}
			  }).addTo(mapLayers.closures);
			}
		  });
		}
	  });
	}

    }

	// Checkbox-Events
	document.getElementById('toggleWaterways').addEventListener('change', e => {
	  if (e.target.checked) {
		mapInstance.addLayer(mapLayers.waterways);
	  } else {
		mapInstance.removeLayer(mapLayers.waterways);
	  }
	});

	document.getElementById('toggleClosures').addEventListener('change', e => {
	  if (e.target.checked) {
		mapInstance.addLayer(mapLayers.closures);
	  } else {
		mapInstance.removeLayer(mapLayers.closures);
	  }
	});

    document.querySelector("date-range-component").addEventListener("dateRangeSelected", e => {
      const { start, end } = e.detail;
	  if (start || end) {
		mapFilter = {
		  start: start 
			? (() => {
				const d = flatpickr.parseDate(start, "d.m.Y");
				d.setHours(0,0,0,0); // Tagesanfang
				return d.getTime();
			  })()
			: null,
		  end: end 
			? (() => {
				const d = flatpickr.parseDate(end, "d.m.Y");
				d.setHours(23,59,59,999); // Tagesende
				return d.getTime();
			  })()
			: null
		};
	  } else {
	  	 mapFilter = {};
	  }
      console.log(`‚úÖ R√ºckgabe: Start = ${start}, Ende = ${end}`);
	  loadMapData();     // Karte neu laden
    });
	
    // View Toggle
    document.querySelectorAll('.view-toggle button').forEach(btn => {
      btn.addEventListener('click', () => {
        const view = btn.dataset.view;
        document.querySelectorAll('.view-toggle button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        document.getElementById('configView').classList.remove('active');
        document.getElementById('mapView').classList.remove('active');

        if (view === 'config') {
          document.getElementById('configView').classList.add('active');
          if (mapUpdateTimer) clearInterval(mapUpdateTimer);
        } else if (view === 'map') {
          document.getElementById('mapView').classList.add('active');
          initMap();
          loadMapData();
          if (initialConfig.pollIntervalHours) {
            mapUpdateTimer = setInterval(loadMapData, initialConfig.pollIntervalHours * 3600000);
          }
        }
      });
    });

    // Update UI labels for map
	function updateMapLabels() {
	  const t = translations[currentLang];
	  document.getElementById('mapWaterwaysLabel').textContent = t.mapWaterwaysLabel;
	  document.getElementById('mapClosuresLabel').textContent = t.mapClosuresLabel;

      const comp = document.querySelector("date-range-component");
	  comp.setAttribute("label-start", t.mapClosureStart);
	  comp.setAttribute("label-end", t.mapClosureEnd);
	  comp.setAttribute("label-today", t.mapClosureToday);
	  comp.setAttribute("label-all", t.mapClosureAll);

	}

    // Initial setup
    updateMapLabels();
	startAutoMode();
	
  </script>
</body>
</html>